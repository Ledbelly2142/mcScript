Enum BME280 As Byte
    REGISTER_DIG_T1 = 0x88
    REGISTER_DIG_T2 = 0x8a
    REGISTER_DIG_T3 = 0x8c
    
    REGISTER_DIG_P1 = 0x8e
    REGISTER_DIG_P2 = 0x90
    REGISTER_DIG_P3 = 0x92
    REGISTER_DIG_P4 = 0x94
    REGISTER_DIG_P5 = 0x96
    REGISTER_DIG_P6 = 0x98
    REGISTER_DIG_P7 = 0x9a
    REGISTER_DIG_P8 = 0x9c
    REGISTER_DIG_P9 = 0x9e
    
    REGISTER_DIG_H1 = 0xa1
    REGISTER_DIG_H2 = 0xe1
    REGISTER_DIG_H3 = 0xe3
    REGISTER_DIG_H4 = 0xe4
    REGISTER_DIG_H5 = 0xe5
    REGISTER_DIG_H6 = 0xe7
    
    REGISTER_CHIPID = 0xd0
    REGISTER_VERSION = 0xd1
    REGISTER_SOFTRESET = 0xe0
    
    REGISTER_CAL26 = 0xe1 // R calibration stored in 0xE1-0xF0
    
    REGISTER_CONTROLHUMID = 0xf2
    REGISTER_STATUS = 0xf3
    REGISTER_CONTROL = 0xf4
    REGISTER_CONFIG = 0xf5
    REGISTER_PRESSUREDATA = 0xf7
    REGISTER_TEMPDATA = 0xfa
    REGISTER_HUMIDDATA = 0xfd
End Enum

Enum mode As Byte
    NORMAL_MODE = 0x01
    FORCED_MODE = 0x02
End Enum


//*=========================================================================*/

Class BME280_Sensor
    // Class To handle BME280 temperature/humidity/pressure BME280_I2C_sensor via I2C
    //Supply voltage VDD main supply voltage range: 1.71 V to 3.6 V
    //VDDIO interface voltage range: 1.2 V to 3.6 V
    //Current consumption 1.8 μA @ 1 Hz humidity and temperature
    //2.8 μA @ 1 Hz pressure and temperature
    //3.6 μA @ 1 Hz humidity, pressure and temperature
    //0.1 μA in sleep mode
    
    //Factory Calibration Factors
    Public dig_T1 As Integer //converted from unsigned Short
    Public dig_T2 As Integer //was Short
    Public dig_T3 As Integer //was Short
    
    Public dig_P1 As Integer //converted from unsigned Short
    Public dig_P2 As Integer //was Short
    Public dig_P3 As Integer //was Short
    Public dig_P4 As Integer //was Short
    Public dig_P5 As Integer //was Short
    Public dig_P6 As Integer //was Short
    Public dig_P7 As Integer //was Short
    Public dig_P8 As Integer //was Short
    Public dig_P9 As Integer //was Short
    
    Public dig_H1 As Integer //was Byte
    Public dig_H2 As Integer //was Short
    Public dig_H3 As Integer //was Byte
    Public dig_H4 As Integer //was Short
    Public dig_H5 As Integer //was Short
    Public dig_H6 As Integer //converted from signed Byte
    
    //raw values as read by readall()
    Public temperature_raw As Integer
    Public pressure_raw As Integer
    Public humidity_raw As Integer
    
    //sensor mode
    Public normal_mode As Boolean = True
    
    //Ambient Temperature adjustment, used in Humidity and Pressure calculations
    Public t_fine As Integer
    
    //I2c device for BME280_I2C_sensor
    Public BME280_I2C_sensor As I2c
    
    //Set devices status as online or not
    Public online As Boolean = False
    
    Public Sub New(addr As Byte)
        BME280_I2C_sensor = I2c.Create(400000, Pin.SCL, Pin.SDA, addr)
        //Reset()
        //Thread.Sleep(1000000)
        Dim chipid As Byte = getChipID()
        If chipid = 0x60 Then
            online = True
            readCoefficients() //load calibration factors
            //publishCoefficients()
            //Set before CONTROL_meas (DS 5.4.3) - register REGISTER_CONTROL
            write8(BME280.REGISTER_CONTROLHUMID, 0x05) //16x oversampling
            normal_mode = True
            write8(BME280.REGISTER_CONFIG, 0xa0) // normal mode samle rate 1000ms
            write8(BME280.REGISTER_CONTROL, 0xb7) // 16x ovesampling, normal mode
            //write8(BME280.REGISTER_CONTROL, 0xB6) // 16x ovesampling, forced mode - see page 26 of DS
            MQTT.Publish("Status", "BME280 Online")
        Else
            online = False
        End If
    End Sub
    
    Public Function getChipID() As Byte
        //ChipID should be 0x60 (96 decimal)
        Return read8(BME280.REGISTER_CHIPID).ToByte()
    End Function
    
    Public Function getVersion() As Byte
        Return read8(BME280.REGISTER_VERSION).ToByte()
    End Function
    
    Public Function getStatus() As Byte
        Return read8(BME280.REGISTER_STATUS).ToByte() //bit 3 = measuring, bit 0 = updating
    End Function
    
    Public Sub Reset()
        write8(BME280.REGISTER_SOFTRESET, 0xb6)
    End Sub
    
    Public Sub SetMode(set_mode As mode)
        Select set_mode
            Case mode.NORMAL_MODE
                normal_mode = True
                write8(BME280.REGISTER_CONTROLHUMID, 0x05) //16x oversampling
                write8(BME280.REGISTER_CONFIG, 0xa0) // normal mode samle rate 1000ms
                write8(BME280.REGISTER_CONTROL, 0xb7) // 16x ovesampling, Normal mode
            Case mode.FORCED_MODE
                normal_mode = False
                write8(BME280.REGISTER_CONTROL, 0xb6) // 16x ovesampling, forced mode
        End Select
    End Sub
    
    Public Sub TakeReading()
        //takes single reading of Temp, Humidity and Pressure.
        normal_mode = False
        write8(BME280.REGISTER_CONTROL, 0xb6) // 16x ovesampling, forced mode
        //LedGreen = False
        Thread.Sleep(1000000)
        //LedGreen = True
    End Sub
    
    Public Function readTemperature() As Float
        //uses 20 bit unsigned int Typical raw result = Temperature_raw 324790
        If online = False Then
            Return 0
        End If
        
        Dim var1 As Integer
        Dim var2 As Integer
        Dim adc_T As Integer = 0
        
        If normal_mode Then
            readall()
            adc_T = temperature_raw
        Else
            TakeReading()
            adc_T = read24(BME280.REGISTER_TEMPDATA)
        End If
        adc_T = adc_T >> 4
        
        MQTT.Publish("Temperature_raw", adc_T)
        
        //adc_T = adc_T / 8
        //var1 = ((adc_T / 8 - dig_T1 * 2) * dig_T2) * 2048
        //var2 = ((((adc_T / 16 - dig_T1) * (adc_T / 16) - dig_T1) / 4096) * dig_T3) / 16384
        var1 = ((((adc_T >> 3) - (dig_T1 << 1))) * dig_T2) >> 11
        var2 = (((((adc_T >> 4) - dig_T1) * ((adc_T >> 4) - dig_T1)) >> 12) * dig_T3) >> 14
        t_fine = var1 + var2
        MQTT.Publish("t_fine", t_fine)
        Dim T As Float = (t_fine * 5 + 128) >> 8
        Return T / 100
    End Function
    
    Public Function readPressure() As Float
        //uses 20 bit unsigned int Typical raw result = Pressure_raw 536681
        If online = False Then
            Return 0
        End If
        readTemperature() // must be done first to get t_fine
        
        Dim var1 As Float
        Dim var2 As Float
        Dim p As Float
        Dim adc_P As Integer = 0
        
        If normal_mode Then
            //readall()   //done by temperature read in normal mode
            adc_P = pressure_raw
        Else
            adc_P = read24(BME280.REGISTER_PRESSUREDATA)
        End If
        
        adc_P = adc_P >> 4
        
        MQTT.Publish("Pressure_raw", adc_P)
        
        Return BME280_compensate_P_int32(adc_P)
    End Function
    
    Public Function BME280_compensate_P_double(adc_P As Integer) As Float
        // Returns pressure in Pa as unsigned 32 bit integer. Output value of “96386” equals 96386 Pa = 963.86 hPa
        
        Dim var1 As Float 
        Dim var2 As Float 
        Dim p As Float
        var1 = t_fine / 2 - 64000.0
        var2 = var1 * var1 * dig_P6 / 32768.0 
        var2 = var2 + var1 * dig_P5 * 2.0 
        var2 = (var2 / 4.0) + (dig_P4 * 65536.0) 
        var1 = (dig_P3 * var1 * var1 / 524288.0 + dig_P2 * var1) / 524288.0 
        var1 = (1.0 + var1 / 32768.0) * dig_P1
        If (var1 = 0.0) Then
            Return 0 // avoid exception caused by division by zero
        End If
        p = 1048576.0 - adc_P 
        p = (p - (var2 / 4096.0)) * 6250.0 / var1 
        var1 = dig_P9 * p * p / 2147483648.0 
        var2 = p * dig_P8 / 32768.0 
        p = p + (var1 + var2 + dig_P7) / 16.0 
        Return p 
    End Function
    
    Public Function BME280_compensate_P_double_2(adc_P As Integer) As Float
        // Returns pressure in Pa as unsigned 32 bit integer. Output value of “96386” equals 96386 Pa = 963.86 hPa
        
        Dim var1 As Float 
        Dim var2 As Float 
        Dim p As Float
        var1 = t_fine / 2 - 64000.0
        var2 = (var1 / 4.0 * var1 / 4.0) / 2048.0 * dig_P6 
        var2 = var2 + (var1 * dig_P5 * 2.0) 
        var2 = (var2 / 4.0) + (dig_P4 * 65536.0) 
        var1 = ((dig_P3 * (var1 / 4.0 * var1 / 4.0) / 8192.0) / 8.0 + (dig_P2 * var1) / 2.0) / 262144.0 
        var1 = ((32768 + var1) * dig_P1) / 32768.0
        If (var1 = 0.0) Then
            Return 0 // avoid exception caused by division by zero
        End If
        p = 1048576.0 - adc_P 
        p = (p - (var2 / 4096.0)) * 3125.0
        If p < 0x80000000 Then
            p = (p / 2.0) / var1
        Else
            p = (p / var1) * 2.0
        End If
        var1 = (dig_P9 * ((p / 8.0) * (p / 8.0)) / 8192.0) / 4096.0 
        var2 = (p / 4.0 * dig_P8) / 8192.0 
        p = p + ((var1 + var2 + dig_P7) / 16.0)
        Return p 
    End Function
    
    Public Function BME280_compensate_P_int32(adc_P As Integer) As Float
        // Returns pressure in Pa as unsigned 32 bit integer. Output value of “96386” equals 96386 Pa = 963.86 hPa
        
        Dim var1 As Integer
        Dim var2 As Integer
        Dim p As Integer
        var1 = (t_fine >> 1) - 64000
        var2 = (((var1 >> 2) * (var1 >> 2)) >> 11) * dig_P6
        var2 = var2 + ((var1 * dig_P5) << 1)
        var2 = (var2 >> 2) + (dig_P4 << 16)
        var1 = (((dig_P3 * (((var1 >> 2) * (var1 >> 2)) >> 13)) >> 3) + ((dig_P2 * var1) >> 1)) >> 18
        var1 = (((32768 + var1)) * dig_P1) >> 15
        If var1 = 0 Then
            Return 0 // avoid exception caused by division by zero
        End If
        p = ((1048576 - adc_P.ZeroExtend()) - (var2 >> 12)) * 3125
        If p < 0x80000000 Then
            p = (p << 1) / var1.ZeroExtend()
        Else
            p = (p / var1.ZeroExtend()) * 2
        End If
        var1 = (dig_P9 * ((((p >> 3) * (p >> 3)) >> 13))) >> 12
        var2 = ((p >> 2) * dig_P8) >> 13
        p = p + ((var1 + var2 + dig_P7) >> 4)
        Return p.ZeroExtend()
    End Function
    
    Public Function readHumidity() As Float
        //uses 16 bit unsigned int Typical raw result = Humidity_raw 27991
        If online = False Then
            Return 0
        End If
        readTemperature() // must be done first to get t_fine
        
        Dim adc_H As Integer = 0
        
        If normal_mode Then
            //readall()   //done by temperature read in normal mode
            adc_H = humidity_raw
        Else
            adc_H = read16(BME280.REGISTER_HUMIDDATA)
        End If
        
        MQTT.Publish("Humidity_raw", adc_H)
        
        Dim v_x1_u32r As Integer
        
        v_x1_u32r = t_fine - 76800
        v_x1_u32r = ((((adc_H << 14) - (dig_H4 << 20) - (dig_H5 * v_x1_u32r)) + 16384) >> 15) * (((((((v_x1_u32r * dig_H6) >> 10) * (((v_x1_u32r * dig_H3) >> 11) + 32768)) >> 10) + 2097152) * dig_H2 + 8192) >> 14)        
        v_x1_u32r = v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * dig_H1) >> 4)
        
        If v_x1_u32r < 0 Then
            v_x1_u32r = 0
        End If
        If v_x1_u32r > 419430400 Then
            v_x1_u32r = 419430400
        End If
        
        //Dim foo as String = If(bar = buz, cat, dog)   //Terniary operator in VB.Net
        //v_x1_u32r = If(v_x1_u32r < 0, 0, v_x1_u32r)
        //v_x1_u32r = If(v_x1_u32r > 419430400, 419430400, v_x1_u32r)
        //v_x1_u32r = If(v_x1_u32r < 0, 0, If(v_x1_u32r > 419430400, 419430400, v_x1_u32r))
        //v_x1_u32r = (v_x1_u32r < 0) ? 0 : v_x1_u32r
        //v_x1_u32r = (v_x1_u32r > 419430400) ? 419430400 : v_x1_u32r
        Dim h As Float = v_x1_u32r >> 12
        Return h / 1024.0
    End Function
    
    //**************************************************************************/
    //*!
    //    Calculates the altitude (in meters) from the specified atmospheric
    //    pressure (in hPa), and sea-level pressure (in hPa).
    //    @param  seaLevel      Sea-level pressure in hPa
    //    @param  atmospheric   Atmospheric pressure in hPa
    //*/
    //**************************************************************************/
    Public Function readAltitude(seaLevel As Float) As Float
        
        // Equation taken from BMP180 datasheet (page 16):
        
        // Note that using the equation from wikipedia can give bad results
        // at high altitude.
        
        Dim atmospheric As Float = readPressure() / 100.0
        Dim factor As Float = atmospheric / seaLevel
        Return 44330.0 * (1.0 - (factor.Pow(0.1903)))
        Return 0
    End Function
    
    //**************************************************************************/
    //*!
    //    Calculates Dew Point (in degrees C) from the specified temperature and
    //    relative Humidity (in %) This equation is an aproximation, but
    //    is fairly accurate for relative humidity values above 50%.   
    //    from:
    //    Lawrence, Mark G., 2005: 
    //    The relationship between relative humidity and the dewpoint temperature in moist air: 
    //    A simple conversion and applications.
    //    Bull. Amer. Meteor. Soc., 86, 225-233. doi: http;//dx.doi.org/10.1175/BAMS-86-2-225
    //*/
    //**************************************************************************/
    Public Function readDewPoint() As Float
        Dim Temperature As Float = readTemperature()
        Dim Humidity As Float = readHumidity()
        Return Temperature - ((100.0 - Humidity)/5.0)
    End Function
    
    //**************************************************************************/
    //*!
    //    Calculates Dew Point (in degrees C) from the specified temperature and
    //    relative Humidity (in %) 
    //    Uses the Magnus Formula (see https://en.wikipedia.org/wiki/Dew_point)
    //*/
    //**************************************************************************/
    Public Function readAccurateDewPoint() As Float
        Dim a As Float = 6.1121
        Dim b As Float = 18.675
        Dim c As Float = 257.14
        Dim d As Float = 234.5
        
        Dim T As Float = readTemperature()
        Dim H As Float = readHumidity()
        
        Dim g as Float = (H/100.0).log() + ((b * T)/ (c + T))
        Dim Dewpoint As Float = (c * g)/(b - g)
        Return Dewpoint
    End Function

    //**************************************************************************/
    //*!
    //    @brief  Writes an 8 bit value over I2C
    //*/
    //**************************************************************************/
    Public Sub SetRegister(reg As Byte)
        Dim data As ListOfByte = New ListOfByte
        data.Add(reg)
        BME280_I2C_sensor.Write(data, True)
    End Sub
    
    Public Sub write8(reg As Byte, value As Byte)
        
        Dim data As ListOfByte = New ListOfByte
        data.Add(reg)
        data.Add(value)
        BME280_I2C_sensor.Write(data, True)
        
    End Sub
    
    //**************************************************************************/
    //*!
    //    @brief  Reads an unsigned 8 bit value over I2C
    //*/
    //**************************************************************************/
    Public Function read8(reg As Byte) As Integer //should return unsigned Byte
        
        SetRegister(reg)
        
        Dim result As Short = 0
        
        Dim value As ListOfByte = BME280_I2C_sensor.Read(1, True)
        If value <> Nothing Then
            result = value(0)
        End If
        
        Return result.ZeroExtend() //return unsigned Integer
    End Function
    
    //**************************************************************************/
    //*!
    //    @brief  Reads a signed 8 bit value over I2C
    //*/
    //**************************************************************************/
    Public Function readS8(reg As Byte) As Integer //should return signed Byte
        Dim result As Byte = read8(reg).ToByte()
        Return result.SignExtend() //return signed Integer
    End Function
    
    //**************************************************************************/
    //*!
    //    @brief  Reads an unsigned 16 bit value over I2C
    //*/
    //**************************************************************************/
    Public Function read16(reg As Byte) As Integer //should return unsigned Short
        Dim result As Short = readS16(reg).ToShort()
        Return result.ZeroExtend()
    End Function
    
    Public Function read16_LE(reg As Byte) As Integer //should return unsigned Short
        Dim result As Short = readS16_LE(reg).ToShort()
        Return result.ZeroExtend()
    End Function
    
    //**************************************************************************/
    //*!
    //    @brief  Reads a signed 16 bit value over I2C
    //*/
    //**************************************************************************/
    Public Function readS16(reg As Byte) As Integer //should return Short
        
        SetRegister(reg)
        
        Dim result As Short = 0
        
        Dim value As ListOfByte = BME280_I2C_sensor.Read(2, True)
        If value <> Nothing Then
            result = (value(0) << 8) | value(1)
        End If
        
        Return result
    End Function
    
    Public Function readS16_LE(reg As Byte) As Integer //should return Short
        Dim result As Short = readS16(reg).ToShort()
        Return (result >> 8) | (result << 8)
    End Function
    
    //**************************************************************************/
    //*!
    //    @brief  Reads a signed 24 bit value over I2C
    //*/
    //**************************************************************************/
    
    Public Function read24(reg As Byte) As Integer
        
        SetRegister(reg)
        
        Dim result As Integer = 0
        
        Dim value As ListOfByte = BME280_I2C_sensor.Read(3, True)
        If value <> Nothing Then
            result = (value(0) << 16) | (value(1) << 8) | value(2)
        End If
        
        Return result
    End Function
    
    //**************************************************************************/
    //*!
    //    @brief  Reads all values (temp/humid/press) values over I2C
    //    reg is start register - to read all read 0xF7 to 0xFE (8 registers)
    //*/
    //**************************************************************************/
    
    Public Sub readall()
        
        SetRegister(0xf7)
        
        Dim value As ListOfByte = BME280_I2C_sensor.Read(8, True)
        If value <> Nothing Then
            temperature_raw = (value(0) << 16) | (value(1) << 8) | value(2)
            pressure_raw = (value(3) << 16) | (value(4) << 8) | value(5)
            humidity_raw = (value(6) << 8) | value(7)
        End If
        
    End Sub
    
    //**************************************************************************/
    //*!
    //    @brief  Reads the factory-set coefficients
    //*/
    //**************************************************************************/
    Public Sub readCoefficients()
        
        dig_T1 = read16_LE(BME280.REGISTER_DIG_T1)
        dig_T2 = readS16_LE(BME280.REGISTER_DIG_T2)
        dig_T3 = readS16_LE(BME280.REGISTER_DIG_T3)
        
        dig_P1 = read16_LE(BME280.REGISTER_DIG_P1)
        dig_P2 = readS16_LE(BME280.REGISTER_DIG_P2)
        dig_P3 = readS16_LE(BME280.REGISTER_DIG_P3)
        dig_P4 = readS16_LE(BME280.REGISTER_DIG_P4)
        dig_P5 = readS16_LE(BME280.REGISTER_DIG_P5)
        dig_P6 = readS16_LE(BME280.REGISTER_DIG_P6)
        dig_P7 = readS16_LE(BME280.REGISTER_DIG_P7)
        dig_P8 = readS16_LE(BME280.REGISTER_DIG_P8)
        dig_P9 = readS16_LE(BME280.REGISTER_DIG_P9)
        
        dig_H1 = read8(BME280.REGISTER_DIG_H1)
        dig_H2 = readS16_LE(BME280.REGISTER_DIG_H2)
        dig_H3 = read8(BME280.REGISTER_DIG_H3)
        dig_H4 = (read8(BME280.REGISTER_DIG_H4) << 4) | (read8(BME280.REGISTER_DIG_H4 + 1) & 0x0f)
        dig_H5 = (read8(BME280.REGISTER_DIG_H5 + 1) << 4) | (read8(BME280.REGISTER_DIG_H5) >> 4)
        dig_H6 = readS8(BME280.REGISTER_DIG_H6) //convert to signed Integer
    End Sub
    
    Public Sub publishCoefficients()
        MQTT.Publish("dig_T1", dig_T1)
        MQTT.Publish("dig_T2", dig_T2)
        MQTT.Publish("dig_T3", dig_T3)
        
        MQTT.Publish("dig_P1", dig_P1)
        MQTT.Publish("dig_P2", dig_P2)
        MQTT.Publish("dig_P3", dig_P3)
        MQTT.Publish("dig_P4", dig_P4)
        MQTT.Publish("dig_P5", dig_P5)
        MQTT.Publish("dig_P6", dig_P6)
        MQTT.Publish("dig_P7", dig_P7)
        MQTT.Publish("dig_P8", dig_P8)
        MQTT.Publish("dig_P9", dig_P9)
        
        MQTT.Publish("dig_H1", dig_H1)
        MQTT.Publish("dig_H2", dig_H2)
        MQTT.Publish("dig_H3", dig_H3)
        MQTT.Publish("dig_H4", dig_H4)
        MQTT.Publish("dig_H5", dig_H5)
        MQTT.Publish("dig_H6", dig_H6)
    End Sub
    
End Class